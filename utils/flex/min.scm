(define default-denominator 0.0001)
(define divide /)
(define (safe-divide num . den)
  (apply divide num (map (lambda (d) (if (= 0 d) default-denominator d)) den)))
;(define safe-divide /)

  (define (bfgs f g x est ftol maxiter)
    (let ((n (vector-length x)))
      (if (null? g) (set! g (generate-gradient-procedure
                              f n (* 1000 *machine-epsilon*))))
      (let loop ((H (m:make-identity n))
                 (x x)
                 (fx (f x))
                 (gx (g x))
                 (count 0))
        (if bfgs-wallp? (print (list x fx gx)))
        (let ((v (matrix*vector H (scalar*vector -1 gx))))
          (if (positive? (v:dot-product v gx))
            (begin
              (if bfgs-wallp?
                 (display (list "H reset to Identity at iteration" count)))
              (loop (m:make-identity n) x fx gx count))
            (let ((r (line-min-davidon f g x v est)))
              (if (eq? (car r) 'no-min)
                (list 'no-min (cons x fx) count)
                (let ((newx (cadr r))
                      (newfx (caddr r)))
                  (if (close-enuf? newfx fx ftol) ;convergence criterion
                    (list 'ok (cons newx newfx) count)
                    (if (fix:= count maxiter)
                      (list 'maxcount (cons newx newfx) count)
                      (let* ((newgx (g newx))
                             (dx (vector-vector newx x))
                             (dg (vector-vector newgx gx))
                             (Hdg (matrix*vector H dg))
                             (dxdg (v:dot-product dx dg))
                             (dgHdg (v:dot-product dg Hdg))
                             (u (vector-vector (scalar*vector (safe-divide 1 dxdg) dx)
  					     (scalar*vector (safe-divide 1 dgHdg) Hdg)))
                             (A (matrix*scalar
  			       (m:outer-product (vector->column-matrix dx)
  						(vector->row-matrix dx))
  			       (safe-divide 1 dxdg)))
                             (B (matrix*scalar
  			       (m:outer-product (vector->column-matrix Hdg)
  						(vector->row-matrix Hdg))
  			       (safe-divide -1 dgHdg)))
                             (C (matrix*scalar
  			       (m:outer-product (vector->column-matrix u)
  						(vector->row-matrix u))
  			       dgHdg))
                             (newH
  			    (matrix+matrix (matrix+matrix H A)
  					   (matrix+matrix B C))))
                          (loop newH newx newfx newgx (fix:+ count 1)))))))))))))

(define (line-min-davidon f g x v est)
  (define (t->x t) (vector+vector x (scalar*vector t v)))
  (define (linef t) (f (t->x t)))
  (define (lineg t) (g (t->x t)))
  (define f0 (linef 0))
  (define g0 (lineg 0))
  (define s0 (safe-divide (- f0 est) -.5 (v:dot-product g0 v)))
  (let loop ((t (if (and (positive? s0) (< s0 1)) s0 1))
             (iter 0))
    (if (> iter 100)
        (list 'no-min)
        (let ((ft (linef t))
              (gt (lineg t)))
          (if (or (>= ft f0)
                  (>= (v:dot-product v gt) 0))
              (let* ((vg0 (v:dot-product v g0))
                     (vgt (v:dot-product v gt))
                     (z (+ (* 3 (- f0 ft) (safe-divide 1 t)) vg0 vgt))
                     (w (sqrt (- (* z z) (* vg0 vgt))))
                     (tstar (* t (- 1 (safe-divide (+ vgt w (- z))
                                         (+ vgt (- vg0) (* 2 w))))))
                     (fstar (linef tstar)))
                 (if (< fstar f0)
                     (list 'ok (t->x tstar) fstar)
                     (loop tstar (+ iter 1))))
              (loop (* t 2) (+ iter 1)))))))